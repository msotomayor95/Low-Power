% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %


\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline
\usepackage{enumitem}

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}

% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ********************************************************* %
% ~~~~~~~~              Code snippets             ~~~~~~~~~ %
% ********************************************************* %

\usepackage{color} % para snipets de codigo coloreados
\usepackage{fancybox}  % para el sbox de los snipets de codigo

\definecolor{litegrey}{gray}{0.94}

\newenvironment{codesnippet}{%
	\begin{Sbox}\begin{minipage}{\textwidth}\sffamily\small}%
	{\end{minipage}\end{Sbox}%
		\begin{center}%
		\vspace{-0.4cm}\colorbox{litegrey}{\TheSbox}\end{center}\vspace{0.3cm}}



% ********************************************************* %
% ~~~~~~~~         Formato de las páginas         ~~~~~~~~~ %
% ********************************************************* %

\usepackage{fancyhdr}
\pagestyle{fancy}

%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ - #1}}

\fancyhf{}

\fancyhead[LO]{Sección \rightmark} % \thesection\ 
\fancyfoot[LO]{\small{Leandro Ezequiel Ruiz, Walter Tejera, Marco Sotomayor}}
\fancyfoot[RO]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\setlength{\hoffset}{-0.8in}
\setlength{\textwidth}{16cm}
%\setlength{\hoffset}{-1.1cm}
%\setlength{\textwidth}{16cm}
\setlength{\headsep}{0.5cm}
\setlength{\textheight}{25cm}
\setlength{\voffset}{-0.7in}
\setlength{\headwidth}{\textwidth}
\setlength{\headheight}{13.1pt}

\renewcommand{\baselinestretch}{1.1}  % line spacing

% ******************************************************** %


\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2020}
\titulo{Trabajo Práctico III}
\subtitulo{System Programming - Low Power}
\integrante{Marco Sotomayor}{731/14}{marco.soto1995@gmail.com}
\integrante{Walter Tejera}{362/15}{wtejerac@gmail.com}


\maketitle
\newpage


\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Objetivo}

Este trabajo pr\'actico consiste en un conjunto de ejercicios en los que se aplican de forma gradual los conceptos de System Programming vistos en las clases te\'oricas y pr\'acticas. Los ejercicios est\'an inspirados en la serie Rick and Morty. 

El trabajo busca construir un sistema m\'inimo que permita correr como m\'aximo 22 tareas concurrentemente a nivel de usuario. Este sistema simulará un universo en el que se encuentran 2 jugadores, Rick y Morty, y un tablero donde se moveran las tareas (mr meeseeks) buscando sumar puntos al recolectar objetos(mega semillas) repartidos por el mapa. Los meeseeks serán creados a partir de la acción de los jugadores y se moverán sobre el tablero de forma autónoma. Cuando un meeseeks llega a alguna de las semillas tanto el meeseeks como la semilla serán eliminadas del mapa y se sumaran 425 puntos al invocador del meeseeks.

Los ejercicios de este trabajo práctico proponen utilizar los mecanismos que posee el procesador
para la programación desde el punto de vista del sistema operativo.

\section{Introducción}

Para este trabajo se utilizará como entorno de pruebas el programa Bochs. El mismo
permite simular una computadora IBM-PC compatible desde el inicio, y realizar además
tareas de debugging. Todo el código provisto para la realización del presente trabajo está
ideado para correr en Bochs de forma sencilla.

Al iniciar, una computadora comienza con la ejecución del POST y el BIOS, el cual se
encarga de reconocer el primer dispositivo de booteo. En este caso dispondremos de un Floppy
Disk como dispositivo de booteo. En el primer sector de dicho floppy, se almacena el boot-
sector. El BIOS se encarga de copiar a memoria 512 bytes del sector, a partir de la dirección
0x7C00. Luego, se comienza a ejecutar el código a partir esta dirección. El boot-sector debe
encontrar en el floppy el archivo kernel.bin y copiarlo a memoria. Éste se copia a partir
de la dirección 0x1200, y luego se ejecuta a partir de esa misma dirección. En la figura 2 se
presenta el mapa de organización de la memoria utilizada por el kernel.

Es importante tener en cuenta que el código del boot-sector se encarga exclusivamente de
copiar el kernel y dar el control al mismo, es decir, no cambia el modo del procesador. El
código del boot-sector, como as\'i todo el esquema de trabajo para armar el kernel y correr
tareas, es provisto por la cátedra.

\section{Desarrrollo}

\subsection{Ejercicios}

\subsubsection{Ejercicio 1}

\begin{enumerate}[label=\alph*)]
	
\item a) Completar la Tabla de Descriptores Globales (
GDT )
con
4
segmentos, dos para código de nivel
0 y 3; y otros dos para datos de nivel 0 y 3. Estos segmentos deben direccionar los primeros
201MB de memoria. En la
gdt ,
por restricción del trabajo práctico, las primeras
10
posiciones
se consideran utilizadas y por ende no deben utilizarlas. El primer índice que deben usar para
declarar los segmentos, es el
10
(contando desde cero).

Editamos el archivo \texttt{gdt.c}, colocando dentro del arreglo de entradas de gdt definido en el archivo inicial, agregando cuatro nuevas entradas, una correspondiente a cada segmento pedido. Las posiciones usadas del arreglo son las primeras 4 desp\'ues de la entrada 9 ya que estas se encuentran reservadas. Para que sea mas f\'acil reconocer cada segmento cada posici\'on tiene un nombre, el cual previamente definimos en el archivo \texttt{defines.h}, con el valor n\'umerico que corresponde a su posici\'on.

Cada entrada de la GDT consiste en un struct \texttt{gdt\_entry}, definido en \texttt{gdt.h}, cuyos valores var\'ian seg\'un las caracter\'isticas del segmento al que apunta. Todos los segmentos definidos tienen base en la posici\'on \texttt{0x00000000} y l\'imite en \texttt{0xC8FF} con granularidad 1 para cubrir los primeros 201MB de memoria. Dependiendo de si es un segmento de nivel 3 o 0, el \textit{DPL} del descriptor de segmento cambiara por \texttt{11} o \texttt{00} respectivamente.

\item Completar el código necesario para pasar a modo protegido y setear la pila del kernel
en la dirección \texttt{0x25000} (es decir, en la base de la pila).

Modificamos el archivo \texttt{kernel.asm} agregando una l\'inea para cargar la direcci\'on de la GDT, con la instrucci\'on \texttt{LGDT}, usando la variable \texttt{GDT\_DESC definida} en \texttt{gdt.h}. Luego habilitamos la A20 Gate para setear el bit de PE (Protected Environment) del registro CR0 en 1 y finalmente realizamos un \textit{jump far} al segmento de c\'odigo de nivel 0 definido en el punto anterior. El offset esta dado por una etiqueta que agregamos abajo, llamada \texttt{modoprotegido}. Al realizar este salto  tambien debimos de agregar una l\'inea que indique el paso a 32 bits.

\item Declarar un segmento adicional que describa el \'area de la pantalla en memoria que pueda ser utilizado s\'olo por el \textit{kernel}.

Editamos el archivo \texttt{gdt.c} para agregar una nueva entrada en la GDT, siguiente a las anteriores y apuntando a un segmento con base \texttt{0xB8000} y l\'imite \texttt{0x1F3F}. Como el tama\~no de la pantalla es de 80x50, la cantidad de p\'ixeles totales es de 4000 px. Sumado a esto, cada pixel es representado por 2 bytes, dando as\'i 8000 bytes para la pantalla por lo que la \'ultima direcci\'on accesible es \texttt{0xB8000 + 0x1F3F} (7999 en decimal).

\item Escribir una rutina que se encargue de limpiar la pantalla y pintar el área del mapa con algún color de fondo, junto con las barras de los jugadores según indica la sección 0.4.5. Para este ejercicio se debe escribir en la pantalla usando el segmento declarado en el punto anterior. Es muy importante tener en cuenta que para los próximos ejercicios se accederá a la memoria de video por medio del segmento de datos.

El ejercicio esta dise\~nado para que podamos ver como escribir en memoria utilizando un segmento distinto al segmento de datos que tenemos seteado por defecto. Para pintar la pantalla iteramos desde \texttt{mov [fs:reg]} donde \texttt{fs} es el selector de segmento de video, con TI en 0 y RPL 00, y \texttt{reg} un registro cualquiera. Una vez que \texttt{reg} vale \texttt{0xA0} significa que llegamos al final de la primera fila por lo que empieza el mapa. La terminaci\'on del mapa se encuentra en el byte \texttt{0x19A0}. Luego solo queda pintar de negro nuevamente el resto de la pantalla, hasta el byte \texttt{0x1F3F}. 
 
\end{enumerate}



 
\end{document}

