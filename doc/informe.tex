% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %


\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline
\usepackage{enumitem}

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}

% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ********************************************************* %
% ~~~~~~~~              Code snippets             ~~~~~~~~~ %
% ********************************************************* %

\usepackage{color} % para snipets de codigo coloreados
\usepackage{fancybox}  % para el sbox de los snipets de codigo

\definecolor{litegrey}{gray}{0.94}

\newenvironment{codesnippet}{%
	\begin{Sbox}\begin{minipage}{\textwidth}\sffamily\small}%
	{\end{minipage}\end{Sbox}%
		\begin{center}%
		\vspace{-0.4cm}\colorbox{litegrey}{\TheSbox}\end{center}\vspace{0.3cm}}



% ********************************************************* %
% ~~~~~~~~         Formato de las páginas         ~~~~~~~~~ %
% ********************************************************* %

\usepackage{fancyhdr}
\pagestyle{fancy}

%\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ - #1}}

\fancyhf{}

\fancyhead[LO]{Sección \rightmark} % \thesection\ 
\fancyfoot[LO]{\small{Walter Tejera, Marco Sotomayor}}
\fancyfoot[RO]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\setlength{\hoffset}{-0.8in}
\setlength{\textwidth}{16cm}
%\setlength{\hoffset}{-1.1cm}
%\setlength{\textwidth}{16cm}
\setlength{\headsep}{0.5cm}
\setlength{\textheight}{25cm}
\setlength{\voffset}{-0.7in}
\setlength{\headwidth}{\textwidth}
\setlength{\headheight}{13.1pt}

\renewcommand{\baselinestretch}{1.1}  % line spacing

% ******************************************************** %


\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2020}
\titulo{Trabajo Práctico III}
\subtitulo{System Programming - Low Power}
\integrante{Marco Sotomayor}{731/14}{marco.soto1995@gmail.com}
\integrante{Walter Tejera}{362/15}{wtejerac@gmail.com}


\maketitle
\newpage


\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage


%\normalsize
\newpage

\section{Objetivo}

Este trabajo pr\'actico consiste en un conjunto de ejercicios en los que se aplican de forma gradual los conceptos de System Programming vistos en las clases te\'oricas y pr\'acticas. Los ejercicios est\'an inspirados en la serie Rick and Morty. 

El trabajo busca construir un sistema m\'inimo que permita correr como m\'aximo 22 tareas concurrentemente a nivel de usuario. Este sistema simulará un universo en el que se encuentran 2 jugadores, Rick y Morty, y un tablero donde se moveran las tareas (mr meeseeks) buscando sumar puntos al recolectar objetos(mega semillas) repartidos por el mapa. Los meeseeks serán creados a partir de la acción de los jugadores y se moverán sobre el tablero de forma autónoma. Cuando un meeseeks llega a alguna de las semillas tanto el meeseeks como la semilla serán eliminadas del mapa y se sumaran 425 puntos al invocador del meeseeks.

Los ejercicios de este trabajo práctico proponen utilizar los mecanismos que posee el procesador
para la programación desde el punto de vista del sistema operativo.

\section{Introducción}

Para este trabajo se utilizará como entorno de pruebas el programa Bochs. El mismo
permite simular una computadora IBM-PC compatible desde el inicio, y realizar además
tareas de debugging. Todo el código provisto para la realización del presente trabajo está
ideado para correr en Bochs de forma sencilla.

Al iniciar, una computadora comienza con la ejecución del POST y el BIOS, el cual se
encarga de reconocer el primer dispositivo de booteo. En este caso dispondremos de un Floppy
Disk como dispositivo de booteo. En el primer sector de dicho floppy, se almacena el boot-
sector. El BIOS se encarga de copiar a memoria 512 bytes del sector, a partir de la dirección
0x7C00. Luego, se comienza a ejecutar el código a partir esta dirección. El boot-sector debe
encontrar en el floppy el archivo kernel.bin y copiarlo a memoria. Éste se copia a partir
de la dirección 0x1200, y luego se ejecuta a partir de esa misma dirección.

Es importante tener en cuenta que el código del boot-sector se encarga exclusivamente de
copiar el kernel y dar el control al mismo, es decir, no cambia el modo del procesador. El
código del boot-sector, como as\'i todo el esquema de trabajo para armar el kernel y correr
tareas, es provisto por la cátedra.

\section{Desarrrollo}

\subsection{Ejercicios}

\subsubsection{Ejercicio 1}

\begin{enumerate}[label=\alph*)]
	
\item a) Completar la Tabla de Descriptores Globales (
GDT )
con
4
segmentos, dos para código de nivel
0 y 3; y otros dos para datos de nivel 0 y 3. Estos segmentos deben direccionar los primeros
201MB de memoria. En la
gdt ,
por restricción del trabajo práctico, las primeras
10
posiciones
se consideran utilizadas y por ende no deben utilizarlas. El primer índice que deben usar para
declarar los segmentos, es el
10
(contando desde cero).

Editamos el archivo \texttt{gdt.c}, colocando dentro del arreglo de entradas de gdt definido en el archivo inicial, agregando cuatro nuevas entradas, una correspondiente a cada segmento pedido. Las posiciones usadas del arreglo son las primeras 4 desp\'ues de la entrada 9 ya que estas se encuentran reservadas. Para que sea mas f\'acil reconocer cada segmento cada posici\'on tiene un nombre, el cual previamente definimos en el archivo \texttt{defines.h}, con el valor n\'umerico que corresponde a su posici\'on.

Cada entrada de la GDT consiste en un struct \texttt{gdt\_entry}, definido en \texttt{gdt.h}, cuyos valores var\'ian seg\'un las caracter\'isticas del segmento al que apunta. Todos los segmentos definidos tienen base en la posici\'on \texttt{0x00000000} y l\'imite en \texttt{0xC8FF} con granularidad 1 para cubrir los primeros 201MB de memoria. Dependiendo de si es un segmento de nivel 3 o 0, el \textit{DPL} del descriptor de segmento cambiara por \texttt{11} o \texttt{00} respectivamente.

\item Completar el código necesario para pasar a modo protegido y setear la pila del kernel
en la dirección \texttt{0x25000} (es decir, en la base de la pila).

Modificamos el archivo \texttt{kernel.asm} agregando una l\'inea para cargar la direcci\'on de la GDT, con la instrucci\'on \texttt{LGDT}, usando la variable \texttt{GDT\_DESC definida} en \texttt{gdt.h}. Luego habilitamos la A20 Gate para setear el bit de PE (Protected Environment) del registro CR0 en 1 y finalmente realizamos un \textit{jump far} al segmento de c\'odigo de nivel 0 definido en el punto anterior. El offset esta dado por una etiqueta que agregamos abajo, llamada \texttt{modoprotegido}. Al realizar este salto  tambien debimos de agregar una l\'inea que indique el paso a 32 bits.

\item Declarar un segmento adicional que describa el \'area de la pantalla en memoria que pueda ser utilizado s\'olo por el \textit{kernel}.

Editamos el archivo \texttt{gdt.c} para agregar una nueva entrada en la GDT, siguiente a las anteriores y apuntando a un segmento con base \texttt{0xB8000} y l\'imite \texttt{0x1F3F}. Como el tama\~no de la pantalla es de 80x50, la cantidad de p\'ixeles totales es de 4000 px. Sumado a esto, cada pixel es representado por 2 bytes, dando as\'i 8000 bytes para la pantalla por lo que la \'ultima direcci\'on accesible es \texttt{0xB8000 + 0x1F3F} (7999 en decimal).

\item Escribir una rutina que se encargue de limpiar la pantalla y pintar el área del mapa con algún color de fondo, junto con las barras de los jugadores según indica la sección 0.4.5. Para este ejercicio se debe escribir en la pantalla usando el segmento declarado en el punto anterior. Es muy importante tener en cuenta que para los próximos ejercicios se accederá a la memoria de video por medio del segmento de datos.

El ejercicio esta dise\~nado para que podamos ver como escribir en memoria utilizando un segmento distinto al segmento de datos que tenemos seteado por defecto. Para pintar la pantalla iteramos desde \texttt{mov [fs:reg]} donde \texttt{fs} es el selector de segmento de video, con TI en 0 y RPL 00, y \texttt{reg} un registro cualquiera. Una vez que \texttt{reg} vale \texttt{0xA0} significa que llegamos al final de la primera fila por lo que empieza el mapa. La terminaci\'on del mapa se encuentra en el byte \texttt{0x19A0}. Luego solo queda pintar de negro nuevamente el resto de la pantalla, hasta el byte \texttt{0x1F3F}. 
 
\end{enumerate}

\subsubsection{Ejercicio 2}

\begin{enumerate}[label=\alph*)]
	\item Completar las entradas necesarias en la IDT para asociar diferentes rutinas a todas las excepciones del procesador. Cada rutina de excepción debe indicar en pantalla qué problema se produjo e interrumpir la ejecución. Posteriormente se modificarán estas rutinas para que se continúe la ejecución, resolviendo el problema y desalojando a la tarea que lo produjo.
	
	En el archivo \texttt{idt.c} modificamos la funci\'on \texttt{idt\_init} para inicializar los 31 (0-30) tipo de excepciones de sistema. Cada entrada tiene seteados los siguientes atributos:
	
	\begin{itemize}
		\item \texttt{off\_set}: La direcci\'on en la cual empieza la rutina de la excepci\'on correspondiente
		\item \texttt{select\_seg}: El selector de segmento con el que se correr\'a la rutina. Tiene que apuntar a un segmento de c\'odigo.
		\item \texttt{attr}: bits correspondientes a los atributos de una \texttt{IDT\_ENTRY}, como el DPL, el bit de Presente, el tama\~no de la compuerta, entre otras.
		
		Estas interrupciones de excepciones tienen un Selector de segmento apuntando a un segmento de c\'odigo de nivel 0 con un RPL en 00 y un TI en 0. con el bit de Presente en 1 y el tama\~no de la compuerta de 32 bits.
	\end{itemize}
	
	\item Hacer lo necesario para que el procesador utilice la IDT creada anteriormente. Generar una excepción para probarla.
	
	En el archivo \texttt{kernel.asm} inicializamos la IDT con la funci\'on \texttt{idt\_init}, para luego setear el puntero a la IDT con LIDT con la variable \texttt{IDT\_DESC}, declarada en \texttt{idt.h}.
	
\end{enumerate}

 \subsubsection{Ejercicio 3}
 
 \begin{enumerate}[label=\alph*)]
 	\item Completar las entradas necesarias en la \texttt{IDT} para asociar una rutina a la interrupción del reloj y otra a la interrupción de teclado. Además crear cuatro entradas adicionales para las interrupciones de software 88, 89, 100, 123.
 	
 	Agregamos 3 entradas m\'as (la 32, 33 y 47) asociadas a la interrupci\'on de reloj, teclado y software respectivamente.
 	
 	Para la interrupci\'on de teclado y de reloj, tendremos un selector de segmento con RPL 00 y TI en 0. Sus atributos son: el bit de presente en 1, el DPL del segmento en 00 y el tama\~no de la compuerta de 32 bits.
 	
 	Para la interrupci\'on de software (syscall) tenemos un selector de segmento de c\'odigo de nivel 0 con RPL 00 y TI en 0. El bit de Presente en 1, el DPL del segmento en 11 (para que las tareas con privilegio de usuario, puedan llamar a esta syscall) y un tama\~no de compuerta de 32 bits.
 	
 	\item Escribir la rutina asociada a la interrupción del reloj, para que por cada \textit{tick} llame a la función \texttt{nextClock}. La misma se encargara de mostrar cada vez que se llame, la animación	de un cursor rotando en la esquina inferior derecha de la pantalla. La función \texttt{nextClock} está definida en \texttt{isr.asm}.
 	
 	En el archivo \texttt{isr.asm} agregamos la interrupción de reloj, que corresponde a la entrada 32 de la IDT , y consiste en guardar los registros, llamar a la función \texttt{pic\_finish1}, indicando que ya	llegamos a atender la interrupción para llamar luego a \texttt{nextClock}, recuperar los registros y volver de la interrupción con un \texttt{iret}.
 	
 	\item Escribir la rutina asociada a la interrupción de teclado de forma que si se presiona cualquiera de 0 a 9, se presente la misma en la esquina superior derecha de la pantalla.
 	
 	
 	Modificamos el archivo \texttt{isr.asm} para agregar la interrupci\'on de teclado, que corresponde a la entrada 33 de la IDT , y que consiste en llamar a \texttt{pic\_finish1}, guardar la información de los registros, leer el c\'odigo ingresado por teclado mediante in 0x60, verificar que no sea mayor a 0x80 (es decir, solt\'e la tecla) y llamar a \texttt{print\_hex} creada en el archivo screen.c que de acuerdo al código recibido, imprime la tecla correspondiente en la pantalla . Finalmente recupera la información de los registros y vuelve de la interrupción.
 	
 	\item Escribir las rutinas asociadas a las interrupciones 88. 89, 100 y 123 para que modifique el valor de eax por 0x58, 0x59, 0x69, y 0x7b, respectivamente. Posteriormente este comportamiento va  ser modificado para atender cada uno de los servicios del sistema.
 	
 	Estas funciones fueron implementadas en \texttt{isr.asm} y modifican el valor de \texttt{eax} por los valores pedidos, para luego volver de la interrupción.
 	
 \end{enumerate}
 
 \subsubsection{Ejercicio 4}
 
 \begin{enumerate}[label=\alph*)]
 	
 	\item Escribir las rutinas encargadas de inicializar el directorio y tablas de páginas para el	\textit{kernel}(\texttt{\textbf{mmu_initKernelDir}}). Se debe generar un directorio de páginas que mapee, usando \textit{identity mapping}, las direcciones 0x00000000 a 0x003FFFFF, como ilustra la figura 3. Además, esta función debe inicializar el directorio de páginas en la dirección 0x25000 y las tablas de páginas según muestra la figura 2.
 	
 
 	Creamos dos structs: \texttt{tr\_page\_directory\_entry} y \texttt{str\_page\_table\_entry} que mediante metodos modelan un cada campo de un directorio de paginas y una tabla de paginas respectivamente.
 	Modificamos la función \texttt{mmu\_initKernelDir} del archivo \texttt{mmu.c}, definiendo la primer entrada del Directorio de P\'aginas en la direcci\'on \texttt{0x00025000}, seteando los bits de \textit{presente}, \textit{read/write} en 1 y la base del la Tabla de p\'aginas en \texttt{0x00026}, mientras que las demás entradas, las inicializamos en 0.
 	
 	Luego definimos cada entrada de la Tabla de P\'aginas situada en la direcci\'on anteriormente mencionada seteando los bit de \textit{presente} y \textit{read/write} en 1 y definiendo la base usando identity mapping(cada base corresponde al indice en la tabla). 
 	
 	Tanto la entrada del Directorio de P\'aginas como todas las entradas de su Tabla de P\'aginas correspondientes tiene privilegios de supervisor (el bit de \textit{U/S} esta en 0). Tambi\'en cabe aclarar la entrada del Directorio de P\'aginas que seteamos tiene el bit de \textit{PS} (Page Size) en 0, lo que significa que las p\'aginas tienen tama\~no 4Kb. Con esto logramos tener un direccionamiento de 4Mb de memoria con \textit{identity mapping}.
 	
 	\item Completar el código necesario para activar paginación.
 	
 	Modificamos el archivo \texttt{kernel.asm} agregando l\'ineas para modificar el registro \texttt{cr3} (que contiene la base del directorio de la tarea actual, en este caso el kernel), para que este apunte a la dirección \texttt{0x00025000} y tenga activo el bit de paginación de cr0.
 	
 	\item Escribir una rutina que imprima el número de libreta de todos los integrantes del grupo en la pantalla.
 	
 	
 	La funci\'on \texttt{imprimir\_libretas} se encuentra en \texttt{screen.h} y se encarga de imprimir un bloque negro en el centro de la pantalla con las libretas de los integrantes.

 \end{enumerate}
 
 \subsubsection{Ejercicio 5}
 
 \begin{enumerate}[label=\alph*)]
 	\item Escribir una rutina (\texttt{mmu\_init}) que se encargue de inicializar las estructuras necesarias para administrar la memoria en el área libre de kernel.
 	
 	La función solo se encarga de inicializar la variable \texttt{next\_free\_kernel\_page},
 	y se encuentra en el archivo \texttt{mmu.c}.
 	
 		\item Escribir dos rutinas encargadas de mapear y desmapear páginas de memoria.
 	\begin{enumerate}[label=\Roman{*}-]
 		\item \texttt{mmu\_mapPage(uint32\_t virtual, uint32\_t cr3, uint32\_t phy)}.
 		
 		Permite mapear la página f\'isica correspondiente a phy en la dirección virtual virtual	utilizando cr3.
 		
 		Agregamos dos parametros a la funci\'on: \texttt{uint8\_t rw} y \texttt{uint8\_t us}. Esta función, implementada en el archivo \texttt{mmu.c}, toma una dirección de memoria virtual,
 		una de memoria f\'isica, un cr3, rw y us. 
 		
 		Primero revisa que esté el bit de presente en 1 en la
 		entrada que marca la dirección virtual del Page Directory correspondiente al cr3, y en 
 		caso de no estarlo, la inicializa, utilizando una nueva página libre del area libre del kernel para crear
 		su correspondiente Page Table. 
 		
 		Luego busca la entrada del Page Table  y la	inicializa, de modo que mapea a la dirección de memoria f\'isica pasada por argumento. Siempre seteando los bits de privilegios y permisos de lectura y escritura de manera acorde a los valores pasados por par\'ametro.
 		
 		\item \texttt{mmu\_unmapPage(uint32\_t cr3, uint32\_t virtual)}
 		
 		Borra el mapeo creado en la dirección virtual virtual utilizando cr3.
 		
 		Esta otra función, también implementada en el archivo \texttt{mmu.c}, simplemente limpia el bit de presente de la entrada del Page Table, de la correspondiente entrada del Page Directory del cr3 pasado por argumento.
 		
 	\end{enumerate}
 	
 	\item Escribir una rutina (\texttt{mmu\_init\_task\_dir}) encargada de inicializar un directorio de páginas y tablas de páginas para una tarea, respetando la figura 3. La rutina debe mapear 4 p\'aginas virtuales para la tarea Rick o Morty, a partir de la dirección virtual 0x1D00000. Esta función debe encargarse de copiar el codigo de la tarea desde la memoria del kernel a la pagina física correspondiente(0x1D00000 para Rick y 0x1D04000 para Morty). Sugerencia agregar a esta función todos los parámetros que considere necesarios.
 	
 	Agregamos la función \texttt{mmu\_init\_task\_dir} en el archivo \texttt{mmu.c}, que toma los siguientes parametros: \texttt{paddr\_t phy\_start, paddr\_t code\_start, size\_t pages, vaddr\_t v\_start, uint8\_t rw, uint8\_t user\_supervisor}. 
	Define un nuevo Directorio de P\'aginas (pidientdo una nueva p\'agina del \'area libre del kernel), realiza identity mapping en la parte de la memoria destinada al kernel y al \'area libre del kernel. Se mapea \texttt{v\_start} a \texttt{phy\_start} tanto el cr3 actual como en el nuevo. Utilizando el cr3 actual  se escribe el codigo de la tarea (\texttt{code\_start}) a travez de \texttt{v\_start}. Luego se desmapea \texttt{v\_start} del cr3 actual. La función devuelve el nuevo cr3.
	
	\item A modo de prueba, construir un mapa de memoria para tareas e intercambiarlo con el del kernel, luego cambiar el color de fondo de la pantalla y volver a la normalidad. Este item no debe estar implementado en la soluci\'on final.
 	
 
 	
 \end{enumerate}
 

 \subsubsection{Ejercicio 6}
 
 \begin{enumerate}[label=\alph*)]
 	\item Definir las entradas en la GDT que considere necesarias para ser usadas como  descriptores de TSS. M\'inimamente, una para ser utilizada por la tarea inicial y otra para la tarea idle.
 	
 	En en archivo \texttt{gdt.c} agregamos 24 nuevas entradas de la GDT. Las primeras dos son para la tarea inicial y la tarea idle, las siguientes dos son para Rick y Morty y las ultimas 20 son las tss correspondientes a los Mr. Meeseeks de cada jugador.
 	
 	Estas entradas tendr\'an un offset l\'imite de 103 bytes y el bit de granularidad en 0, haciendo que se puedan acceder a 104 bytes del segmento de TSS. Todos tienen un DPL en 00 ya que solo quiero que el Kernel tenga acceso a estos segmentos. Las tss de las tareas inicial, idle, Rick y Morty tendran el bit de presente en 1, mientras que las de los Mr. Meeseeks permaneceran en 0 hasta que sean creadas por algun jugador.
 	
 	\item Completar la entrada de la \texttt{TSS} de la tarea \texttt{Idle} con la información de la tarea \texttt{Idle}. Esta información se encuentra en el archivo \texttt{tss.c}. La tarea \texttt{Idle} se encuentra en la dirección	0x00018000. La pila se alojará en la misma dirección que la pila del kernel y será mapeada con identity mapping. Esta tarea ocupa 1 página de 4KB y debe ser mapeada con identity mapping. Además, la misma debe compartir el mismo CR3 que el kernel.
 	
 	Definimos en \texttt{tss.c} la variable \texttt{tss\_iddle} que toma el cr3 actual mediante la funcion \texttt{rcr3()}, con la misma pila que nuestro kernel (0x25000), el eip en 0x18000. Luego, le seteamos los selectores de segmento de la siguiente forma:
 	
 	\begin{itemize}
 		\item \texttt{es}: GDT\_IDX\_DATA\_0 $\ll$ 3
 		\item \texttt{cs}: GDT\_IDX\_CODE\_0 $\ll$ 3
 		\item \texttt{ss}: GDT\_IDX\_DATA\_0 $\ll$ 3
 		\item \texttt{ds}: GDT\_IDX\_DATA\_0 $\ll$ 3
 		\item \texttt{fs}: GDT\_IDX\_DATA\_0 $\ll$ 3
 		\item \texttt{gs}: GDT\_IDX\_DATA\_0 $\ll$ 3
 	\end{itemize}
 	 
 	
 	Tanto GDT\_IDX\_DATA\_0 como GDT\_IDX\_CODE\_0 son reemplazos sintacticos definidos en defines.h con los indices al segmento de datos y codigo de nivel 0 respectivamente.
 	
 	\item Completar la entrada de la GDT correspondiente a la tarea \textit{inicial}.
 	\item Completar la entrada de la GDT correspondiente a la tarea \textit{idle}.
 	
 	En estos dos ejercicios, usamos la funcion \texttt{tss\_init()} la cual setea las bases de las tss en la gdt, ya que no pueden resolverse en tiempo de compilaci\'on.
 	
 	\item Escribir el código necesario para ejecutar la tarea \texttt{Idle}, es decir, saltar intercambiando las \texttt{TSS}, entre la tarea inicial y la tarea \texttt{Idle}.
 	
 	En \texttt{kernel.asm}, realizamos un \texttt{jmp far} a la entrada de la GDT donde se encuentra ubicado el descriptor de la TSS de la tarea Idle con offset 0.
 	
 	\item Construir una función que complete una TSS con los datos correspondientes a una tarea. Esta función será utilizada más adelante para crear una tarea. El código de las tareas se encuentra a partir de la dirección 0x00010000 ocupando cuatro páginas de 4kb cada una según indica la figura 2. Para la dirección de la pila se debe utilizar el mismo espacio de la tarea, la misma crecerá
 	desde la base del código de la tarea. Para el mapa de memoria se debe construir uno nuevo utilizando la función \texttt{mmu\_init\_task\_dir}. Además, tener en cuenta que cada tarea utilizará una pila distinta de nivel 0, para esto se debe pedir una nueva página del área libre de kernel a tal f\'in.
 	
 	Para este ejercicio, tendremos un array de tss, llamado \texttt{tss\_tasks} de 22 posiciones, correspondientes a Rick, Morty y a los Mr Meeseeks de cada uno. Rick y morty estaran en \texttt{tss\_tasks[0]} y \texttt{tss\_tasks[1]} mientras que los Mr. Meeseeks estar\'an e las posiciones restantes. En las posiciones pares, tendremos a los Mr. Meeseeks de Rick y en las impares los de Morty. 
 	
 	Debido a esto separamos la creaci\'on de la tss de una tarea en dos:
 	
 	\begin{itemize}
 		\item creaci\'on de tss para Rick y Morty: Definimos en la funcion \texttt{tss\_init} los valores tanto para rick como para Morty. Estos se crearan con un nuevo cr3 (con el codigo de las tareas en )
 		\item creaci\'on de tss para un Mr. Meeseeks: 
 	\end{itemize}
 
 	% falta terminar esto. Lo sigo mañana.
 \end{enumerate}
 
\end{document}

